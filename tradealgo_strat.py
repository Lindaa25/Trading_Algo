# -*- coding: utf-8 -*-
"""bottradealgo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/Lindaa25/e9f8f55e8f6239307d5e4b665aae897e/bottradealgo.ipynb

# Bot TradeAlgo

##Import des modules

Installation des modules
"""

# Pour la régression linéaire
!pip install yfinance
!pip install pandas
!pip install pandas_ta
!pip install ta
#Pour le bot
!pip install ftx

"""Import des modules"""

# Pour la régression linéaire
import pandas as pd
import yfinance as yf
import ta
import pandas_ta as pda
import matplotlib.pyplot as plt
import numpy as np
from termcolor import colored
from datetime import datetime

# Pour le bot
import ftx
import time
import json
from math import *
from datetime import date
from datetime import timedelta

"""##Modèle de régression linéaire

###Variables explicatives
"""

def add_macd(data):
    MACD = ta.trend.MACD(close=data['Close'], window_fast=12, window_slow=26, window_sign=9)
    data['MACD'] = MACD.macd()
    data['MACD_SIGNAL'] = MACD.macd_signal()
    data['MACD_DIFF'] = MACD.macd_diff() #Histogramme MACD
    
def add_Bollinger(data):
  BOL_BAND = ta.volatility.BollingerBands(close=data['Close'], window=20, window_dev=2)
  data['BOL_H_BAND'] = BOL_BAND.bollinger_hband() #Bande Supérieur
  data['BOL_L_BAND'] = BOL_BAND.bollinger_lband() #Bande inférieur
  data['BOL_diff']=data['BOL_H_BAND']-data['BOL_L_BAND']

def add_RSI(data):
  data['RSI'] =ta.momentum.rsi(close=data['Close'], window=10)

  for k in range(len(data['RSI'])):
    if data['RSI'][k] <= 30:     #mettre à -1 si inférieur à 30
        data['RSI'][k]=-1
    elif 30<=data['RSI'][k]<=70: #mettre à 0 si RSI compris entre 30 et 70
        data['RSI'][k]=0
    else:                #mettre à 1 si supérieur à 70
        data['RSI'][k]=1

def add_CAC40(data,start_date,end_date):
  CAC="^FCHI"
  dfCAC = yf.Ticker(CAC)
  dfCAC=dfCAC.history(period="1d", start=start_date, end=end_date)
  data["CAC40"]=dfCAC['Close']
  
def add_AwsomeOscillator(data):
  data['AWESOME_OSCILLATOR'] = ta.momentum.awesome_oscillator(high=data['High'], low=data['Low'], window1=5, window2=34)
  
def  add_Ichimoku(data):
  data['KIJUN'] = ta.trend.ichimoku_base_line(high=data['High'], low=data['Low'], window1=9, window2=26)
  data['Kijun_diff']=data['Close']-data['KIJUN']
  
def add_ATR(data):
  data['ATR'] = ta.volatility.average_true_range(high=data['High'], low=data['Low'], close=data['Close'], window=14)

# add_Volume (qui est déjà dans le tableau)

"""###Création du modèle"""

def import_data(ticket,date_debut,date_fin):
    """Import des données de l'action 'ticket' entre 'date_debut' et 'date_fin' depuis YahooFinance"""
    data = yf.Ticker(ticket)
    data=data.history(period="1d", start=date_debut, end=date_fin)
    return data


def ajout_VE_Data(data,date_debut,date_fin):
    add_macd(data)
    add_Bollinger(data)
    add_RSI(data)
    #add_Volume(data) #Il y est de base dans data
    #add_CAC40(data,date_debut,date_fin)
    add_AwsomeOscillator(data)
    add_Ichimoku(data)
    add_ATR(data)


def creationYrendements(data):
    rd=[]
    for k in range(len(data['Close'])-1):
        r=(data['Close'][k+1]-data['Close'][k])/data['Close'][k]
        rd.append(r)

    #rendement
    Y=np.array(rd)
    return Y

def creationX(data):
    l=[]
    Y=creationYrendements(data)
    for k in range(len(Y)):
        l.append([])
    print(len(l))
    for k in range(len(l)):
        l[k].append(1)
        l[k].append(data['MACD_DIFF'][k+1])
        if Y[k]<0 :
          l[k].append(-data['BOL_diff'][k+1])
        else :
          l[k].append(data['BOL_diff'][k+1])
        l[k].append(data['RSI'][k+1])
        #l[k].append(data['CAC40'][k+1])
        l[k].append(data['Volume'][k+1])
        l[k].append(data['AWESOME_OSCILLATOR'][k+1])
        l[k].append(data['Kijun_diff'][k+1])
        l[k].append(data['ATR'][k+1])
    return np.array(l)

def creationBeta(X,Y):
    beta = ((X.T).dot(X))
    beta=np.linalg.inv(beta)
    beta=beta.dot(X.T)
    beta=beta.dot(Y)
    return beta

def SortMoiUneRegLin(ticker,date_debut,date_fin):
    Data=import_data(ticker, date_debut, date_fin)
    ajout_VE_Data(Data,date_debut,date_fin)
    Data=Data.loc["2022-1-3":]
    X=creationX(Data)
    Y=creationYrendements(Data)
   
    #return Data
    return (creationBeta(X,Y),X,Y)

"""##Significativité du modèle"""

beta,X,Y=SortMoiUneRegLin("AIR.PA","2021-11-01","2022-5-29")
beta

beta,X,Y=SortMoiUneRegLin("TSLA","2021-11-01","2022-5-29")
beta

beta,X,Y=SortMoiUneRegLin("BTC-USD","2021-11-01","2022-5-29")
beta

beta,X,Y=SortMoiUneRegLin("BCO.DE","2021-11-01","2022-5-29")

beta,X,Y=SortMoiUneRegLin("TTE","2021-11-01","2022-5-29")

"""Calcul des estimations des rendements"""

#Calcul des yi chapeau
ychap=[]
S=0
for i in range(X.shape[0]):
  for j in range(X.shape[1]):
    S+= beta[j]*X[i][j]
  ychap.append(S)
  S=0

"""Moyenne des rendements réels"""

#Calcul yn barre

ybarre=sum(Y)/len(Y)
ybarre

"""Calcul SCT, SCE, SCR et R^2"""

#Calcul SCT, SCE, SCR et R^2

SCT=sum((Y-ybarre)**2)
print("SCT=",SCT)

SCE=sum((ychap-ybarre)**2)
print("SCE=",SCE)

SCR=SCT-SCE
print("SCR=",SCR)

R=SCE/SCT
print("R^2=", R)
F=(SCE/8)/(SCR/93)
print("F=",F)

diff=sum(Y-ychap)/len(Y)
print("Moyenne des écarts entre Y et l'estimation de Y :",diff)

#modèle globalement significatif car F>fisher à alpha=5%

"""##Bot de trading

###Fonctions utiles

Stockage des valeurs des variables explicatives aujourd'hui
"""

def get_X_actuel(df):
  """df = pd.DataFrame -- tableau contenant les dernières données boursières à partir desquelles construire les Variables Explicatives d'aujourd'hui"""
  
  # valCAC=getCAC() 
  # à définir si on change de plateforme et qu'il y a le CAC dessus
  
  #valMACD
  MACD = ta.trend.MACD(close=df['close'], window_fast=12, window_slow=26, window_sign=9)
  df['MACD_DIFF'] = MACD.macd_diff() #Histogramme MACD
  valMACD = list(df['MACD_DIFF'])[-1]

  #valRSI
  df['RSI'] = ta.momentum.rsi(close=df['close'], window=14)
  valRSItemp = list(df['RSI'])[-1]
  valRSI=0
  if valRSItemp<=30:
    valRSI=-1
  elif valRSI<=70:
    valRSI=0
  else:
    valRSI=1
  
  #valBOLL
  BOL_BAND = ta.volatility.BollingerBands(close=df['close'], window=20, window_dev=2)
  df['BOL_H_BAND'] = BOL_BAND.bollinger_hband() #Bande Supérieur
  df['BOL_L_BAND'] = BOL_BAND.bollinger_lband() #Bande inférieur
  valBOLL=list(df['BOL_H_BAND'])[-1]-list(df['BOL_L_BAND'])[-1]
  prix1=list(df['close'])[-1]
  prix2=list(df['close'])[-2]
  r=(prix2-prix1)/prix2
  if r<=0:
    valBOLL=-valBOLL

  #valVOL
  valVOL=list(df['volume'])[-1]

  #valAWS
  df['AWESOME_OSCILLATOR'] = ta.momentum.awesome_oscillator(high=df['high'], low=df['low'], window1=5, window2=34)
  valAWS=list(df['AWESOME_OSCILLATOR'])[-1]

  #valICH
  df['KIJUN'] = ta.trend.ichimoku_base_line(high=df['high'], low=df['low'], window1=9, window2=26)
  df['Kijun_diff']=df['close']-df['KIJUN']
  valICH=list(df['Kijun_diff'])[-1]

  #valATR
  df['ATR'] = ta.volatility.average_true_range(high=df['high'], low=df['low'], close=df['close'], window=14)
  valATR=list(df['ATR'])[-1]

  return [1, valMACD, valBOLL, valRSI, valVOL, valAWS,valICH, valATR] #valCAC à placer au bon endroit si on l'utilise comme variable explicative

"""Calcul du rendement à partir du modele"""

def Rendement_actuel(X_actuel,beta):
  """Calcul du rendement estimé grâce à la régression linéaire (les bêtas)"""
  res=beta[0]
  for i in range(1,len(beta)):
    res+=beta[i]*X_actuel[i]
  return res

"""Conditions d'achat et de vente de l'actif"""

def conditionAchatActif(rendement):
  flag=False
  if rendement>=0.05:
    flag=True
  return flag

def conditionVenteActif(rendement):
  flag=True
  if rendement<0.0:
    flag=True
  return flag

"""#Annexes

##Prédiction des rendements futur
"""

!pip install sklearn

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

x_train,x_test,y_train,y_test=train_test_split(X,Y,test_size=0.2,random_state=0)

#shapes of splitted data
print("X_train:",x_train.shape)
print("X_test:",x_test.shape)
print("Y_train:",y_train.shape)
print("Y_test:",y_test.shape)

linreg=LinearRegression()
linreg.fit(x_train,y_train)

y_pred=linreg.predict(x_test)
y_pred

pred_df=pd.DataFrame({'Actual Value':y_test,'Predicted Value':y_pred,'Difference':y_test-y_pred})

pred_df

plt.scatter(y_test,y_pred);
plt.xlabel('Actual');
plt.ylabel('Predicted');